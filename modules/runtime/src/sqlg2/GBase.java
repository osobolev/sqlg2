package sqlg2;

import sqlg2.db.*;
import sqlg2.queries.QueryParser;

import java.io.IOException;
import java.io.OutputStream;
import java.io.Writer;
import java.lang.reflect.Constructor;
import java.math.BigDecimal;
import java.sql.*;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * Base class for all classes which are processed by preprocessor. Wraps access to JDBC methods allowing
 * preprocessor to intercept them and extract required information.
 *
 * This class itself is not thread-safe, so it cannot be used by more than
 * one thread at a time. Use wrappers generated by preprocessor to access business methods.
 */
@SuppressWarnings({"UnusedDeclaration", "JavadocReference"})
public class GBase implements ISimpleTransaction {

    /**
     * Use it for {@code autoKeys} parameter of {@link #prepareStatementKey} to
     * retrieve all generated columns.
     * @see PrepareKey#value()
     */
    public static final String[] ALL_KEYS = new String[0];

    static GTest test = null;

    final LocalWrapperBase lwb;
    private List<Statement> statements = null;
    private String lastSql = null;
    private Parameter[] lastParams = null;

    /**
     * Constructor. Usually it is called by generated wrappers.
     *
     * @param lwb wrapper for this object
     */
    public GBase(LocalWrapperBase lwb) {
        this.lwb = lwb;
    }

    /**
     * Returns true if method is called at preprocessing time (false at application run time).
     */
    public static boolean isTesting() {
        return test != null;
    }

    private Connection getConnection() throws SQLException {
        return lwb.getConnection();
    }

    /**
     * Access to raw JDBC connection. Can be used <b>only</b> at application run time, not at preprocess time,
     * so check {@link #isTesting} before calling this method.
     */
    protected final Connection getJdbcConnection() throws SQLException {
        if (test != null)
            throw new IllegalStateException("Cannot use Connection in preprocess mode");
        return getConnection();
    }

    /**
     * SQL tracing. Usually called by generated wrappers.
     *
     * @param ok false if SQL caused an error
     * @param t0 business method start time (as in {@link System#currentTimeMillis()}
     */
    public final void traceSql(boolean ok, long t0) {
        long time;
        if (t0 != Long.MIN_VALUE) {
            time = System.currentTimeMillis() - t0;
        } else {
            time = 0;
        }
        lwb.trace(ok, time, lastSql, lastParams);
        lastSql = null;
        lastParams = null;
    }

    private void setSql(String sql, Parameter[] params) {
        lastSql = sql;
        lastParams = params;
    }

    private void statementCreated(Statement stmt, String sql) {
        if (test != null) {
            test.statementCreated(stmt, sql);
        }

        if (statements == null) {
            statements = new ArrayList<>();
        }
        statements.add(stmt);
    }

    ///////////////////////////////// Query piece creation /////////////////////////////////

    /**
     * Used for preprocessor-generated query pieces (see {@link Query})
     */
    public static QueryPiece createQueryPiece(QueryPiece query) {
        return query;
    }

    /**
     * Creates SQL query piece containing query text and its parameters.
     * Example:
     * <pre>
     * QueryPiece piece = createQueryPiece(" AND type_id = ?", in(typeId, Long.class));
     * </pre>
     * It is more convenient to use {@link Query} annotation to generate such pieces than
     * to use this method manually.
     * <p>
     * After piece is created, it can be used to build large query (see {@link QueryBuilder}) or execute query
     * (see {@link #prepareStatement(QueryPiece)})
     *
     * @param sql query text, possibly containing references to parameters in the form of {@code ?}
     * @param params query parameters, see {@link #in}
     */
    public static QueryPiece createQueryPiece(CharSequence sql, Parameter... params) {
        return new QueryPiece(sql, params);
    }

    ///////////////////////////////// Statement preparation /////////////////////////////////

    private PreparedStatement doPrepareStatement(String sql, String[] autoKeys, Parameter[] params) throws SQLException {
        setSql(sql, params);
        String parsedSql = QueryParser.parseQuery(sql); // todo: if !testing, only remove specials?
        Connection connection = getConnection();
        PreparedStatement stmt;
        if (autoKeys != null) {
            if (autoKeys.length > 0) {
                DatabaseMetaData meta = connection.getMetaData();
                String[] autoColumns;
                if (meta.storesUpperCaseIdentifiers()) {
                    autoColumns = new String[autoKeys.length];
                    for (int i = 0; i < autoKeys.length; i++) {
                        autoColumns[i] = autoKeys[i].toUpperCase();
                    }
                } else if (meta.storesLowerCaseIdentifiers()) {
                    autoColumns = new String[autoKeys.length];
                    for (int i = 0; i < autoKeys.length; i++) {
                        autoColumns[i] = autoKeys[i].toLowerCase();
                    }
                } else {
                    autoColumns = autoKeys;
                }
                stmt = connection.prepareStatement(parsedSql, autoColumns);
            } else {
                stmt = connection.prepareStatement(parsedSql, Statement.RETURN_GENERATED_KEYS);
            }
        } else {
            stmt = connection.prepareStatement(parsedSql);
        }
        statementCreated(stmt, parsedSql);
        Parameter.setParameters(this, stmt, params);
        return stmt;
    }

    /**
     * Creates prepared statement from SQL query and its parameters.
     * Later this statement can be executed by {@link #executeUpdate} or by one of many selection methods.
     * Example:
     * <pre>
     * PreparedStatement stmt = prepareStatement("SELECT value FROM table WHERE id = ?", in(id, Long.class));
     * int result = singleRowQueryReturningInt(stmt);
     * </pre>
     * It is more convenient to use {@link Prepare} annotation to generate such queries than
     * to use this method manually.
     *
     * @param sql query text, possibly containing references to parameters in the form of {@code ?}
     * @param params query parameters, see {@link #in}
     */
    public final PreparedStatement prepareStatement(String sql, Parameter... params) throws SQLException {
        return doPrepareStatement(sql, null, params);
    }

    /**
     * Creates prepared statement with auto-generated keys from SQL query and its parameters.
     * Later this statement can be executed by {@link #executeUpdate} or by one of many selection methods.
     * Example:
     * <pre>
     * PreparedStatement stmt = prepareStatementKey(new String[] {"id"}, "INSERT INTO table (name) values ('test')");
     * executeUpdate(stmt);
     * int generatedId = getGeneratedKeys()[0].intValue();
     * </pre>
     * It is more convenient to use {@link PrepareKey} annotation to generate such queries than
     * to use this method manually.
     *
     * @param autoKeys array of column names which are auto-generated.
     *                 Pass {@link #ALL_KEYS} to retrieve all generated columns (does not work on some DBs).
     * @param sql query text, possibly containing references to parameters in the form of {@code ?}
     * @param params query parameters, see {@link #in}
     */
    public final PreparedStatement prepareStatementKey(String[] autoKeys, String sql, Parameter... params) throws SQLException {
        return doPrepareStatement(sql, autoKeys, params);
    }

    /**
     * Creates prepared statement from a piece containing SQL query and its parameters.
     * Later this statement can be executed by {@link #executeUpdate} or by one of many selection methods.
     * Example:
     * <pre>
     * PreparedStatement stmt = prepareStatement("SELECT value FROM table WHERE id = ?", in(id, Long.class));
     * int result = singleRowQueryReturningInt(stmt);
     * </pre>
     * It is more convenient to use {@link Prepare} annotation to generate such queries than
     * to use this method manually.
     *
     * @param query query piece containing SQL query and its parameters
     */
    public final PreparedStatement prepareStatement(QueryPiece query) throws SQLException {
        return doPrepareStatement(query.sql, null, query.data);
    }

    /**
     * Creates prepared statement with auto-generated keys from a piece containing SQL query and its parameters.
     * Later this statement can be executed by {@link #executeUpdate} or by one of many selection methods.
     * Example:
     * <pre>
     * PreparedStatement stmt = prepareStatementKey(new String[] {"id"}, "INSERT INTO table (name) values ('test')");
     * executeUpdate(stmt);
     * int generatedId = getGeneratedKeys()[0].intValue();
     * </pre>
     * It is more convenient to use {@link PrepareKey} annotation to generate such queries than
     * to use this method manually.
     *
     * @param autoKeys array of column names which are auto-generated.
     *                 Pass {@link #ALL_KEYS} to retrieve all generated columns (does not work on some DBs).
     * @param query query piece containing SQL query and its parameters
     */
    public final PreparedStatement prepareStatementKey(String[] autoKeys, QueryPiece query) throws SQLException {
        return doPrepareStatement(query.sql, autoKeys, query.data);
    }

    /**
     * Creates CallableStatement for stored procedure (or PL/SQL block) call.
     * @param sql stored procedure to call.
     * Syntax is the same as for {@link Connection#prepareCall(String)}:
     * <ul>
     * <li>{ call proc_name(params) } or { ? = func_name(params) }
     * <li>begin ... end;
     * </ul>
     */
    public final CallableStatement prepareCall(String sql) throws SQLException {
        setSql(sql, null);
        CallableStatement stmt = getConnection().prepareCall(sql);
        statementCreated(stmt, sql);
        return stmt;
    }

    /**
     * For internal use. Do not use this method at runtime, it throws exception when not preprocessing.
     */
    public final Parameter inP(Object value, String paramId) {
        if (test != null) {
            Class<?> cls = test.setParamType(paramId, value.getClass());
            return Parameter.in(value, cls);
        } else {
            throw new SQLGException("No type is defined for parameter " + paramId);
        }
    }

    /**
     * Same as {@link #in} but generated by preprocessor.
     */
    public final <T> Parameter inP(T value, Class<T> cls) {
        return in(value, cls);
    }

    /**
     * Creates parameter for prepared statement.
     *
     * @param value parameter value. Can be null.
     * @param cls parameter class. Should be not null. Supported types:
     * <ul>
     * <li>{@code Byte}
     * <li>{@code Short}
     * <li>{@code Integer}
     * <li>{@code Long}
     * <li>{@code Float}
     * <li>{@code Double}
     * <li>{@code BigDecimal}
     * <li>{@code String}
     * <li>{@code byte[]}
     * <li>{@code java.sql.Date}
     * <li>{@code java.sql.Time}
     * <li>{@code java.sql.Timestamp}
     * <li>{@code java.util.Date} - converted to {@code java.sql.Timestamp}
     * <li>{@code Boolean}
     * <li>custom types are supported with {@link Mapper} and {@link RuntimeMapper}
     * </ul>
     */
    public static <T> Parameter in(T value, Class<T> cls) {
        return Parameter.in(value, cls);
    }

    /**
     * For internal use. Do not use this method at runtime, it throws exception when not preprocessing.
     */
    public final Parameter outP(Object value, String paramId) {
        if (test != null) {
            test.setParamType(paramId, value.getClass().getComponentType());
            return out(value);
        } else {
            throw new SQLGException("No type is defined for out parameter " + paramId);
        }
    }

    /**
     * Same as {@link #out} but generated by preprocessor.
     */
    public final Parameter outP(Object value) {
        return out(value);
    }

    /**
     * Creates OUT parameter for stored procedure call.
     *
     * @param value Should be one of:
     * <ol>
     * <li>an array with at least one element to store output value
     * <li>{@link TypedList}
     * </ol>
     * Should be not null.
     */
    public static Parameter out(Object value) {
        if (value instanceof TypedList) {
            return Parameter.outResultSet((TypedList<?>) value);
        } else {
            if (test != null) {
                if (value == null || !value.getClass().isArray())
                    throw new SQLGException("Parameter should be an array");
            }
            return Parameter.out(value);
        }
    }

    /**
     * Creates OUT parameter for stored procedure call.
     *
     * @param jdbcType type of parameter. Output value will be in the resulting array of {@link #callStoredProc}.
     * Supported types (contants in {@link Types} class):
     * <ul>
     * <li>{@code TINYINT} - returned as {@code Byte}
     * <li>{@code SMALLINT} - returned as {@code Short}
     * <li>{@code INTEGER} - returned as {@code Integer}
     * <li>{@code BIGINT} - returned as {@code Long}
     * <li>{@code FLOAT} - returned as {@code Float}
     * <li>{@code REAL} and {@code DOUBLE} - returned as {@code Double}
     * <li>{@code DECIMAL} and {@code NUMERIC} - returned as {@code BigDecimal}
     * <li>{@code CHAR}, {@code VARCHAR} and {@code LONGVARCHAR} - returned as {@code String}
     * <li>{@code BINARY}, {@code VARBINARY} and {@code LONGVARBINARY} - returned as {@code byte[]}
     * <li>{@code DATE} - returned as {@code java.sql.Date}
     * <li>{@code TIME} - returned as {@code java.sql.Time}
     * <li>{@code TIMESTAMP} - returned as {@code java.sql.Timestamp}
     * <li>{@code BOOLEAN} - returned as {@code Boolean}
     * <li>{@code CLOB} - returned as {@code String}
     * <li>{@code BLOB} - returned as {@code byte[]}
     * <li>other constants invoke {@link CallableStatement#getObject} method to get result
     * </ul>
     */
    public static Parameter outJdbc(int jdbcType) {
        return Parameter.outJdbc(jdbcType);
    }

    /**
     * Creates OUT parameter for cursor parameters.
     *
     * @param list list to populate with rows from result set
     */
    public static Parameter outResultSet(TypedList<?> list) {
        return Parameter.outResultSet(list);
    }

    /**
     * Binds prepared statement parameters to specific values.
     *
     * @param st SQL statement
     * @param in parameter values
     */
    public final void setParameters(PreparedStatement st, Parameter... in) throws SQLException {
        Parameter.setParameters(this, st, in);
    }

    /**
     * Binds single prepared statement parameter to specific value.
     *
     * @param st SQL statement
     * @param index index of the parameter (from 1)
     * @param value parameter value
     * @param cls parameter class
     */
    public final <T> void setParameter(PreparedStatement st, int index, T value, Class<T> cls) throws SQLException {
        Parameter.in(value, cls).set(this, st, index);
    }

    ///////////////////////////////// Base methods for selection /////////////////////////////////

    private abstract static class Converter<T> {

        abstract T convert(ResultSet rs) throws SQLException;
    }

    private static final Converter<Integer> INT_CONVERTER = new Converter<Integer>() {
        Integer convert(ResultSet rs) throws SQLException {
            return rs.getInt(1);
        }
    };
    private static final Converter<Long> LONG_CONVERTER = new Converter<Long>() {
        Long convert(ResultSet rs) throws SQLException {
            return rs.getLong(1);
        }
    };
    private static final Converter<Double> DOUBLE_CONVERTER = new Converter<Double>() {
        Double convert(ResultSet rs) throws SQLException {
            return rs.getDouble(1);
        }
    };
    private static final Converter<String> STRING_CONVERTER = new Converter<String>() {
        String convert(ResultSet rs) throws SQLException {
            return rs.getString(1);
        }
    };
    private static final Converter<byte[]> BYTES_CONVERTER = new Converter<byte[]>() {
        byte[] convert(ResultSet rs) throws SQLException {
            return rs.getBytes(1);
        }
    };
    private static final Converter<BigDecimal> BIGDECIMAL_CONVERTER = new Converter<BigDecimal>() {
        BigDecimal convert(ResultSet rs) throws SQLException {
            return rs.getBigDecimal(1);
        }
    };
    private static final Converter<Date> DATE_CONVERTER = new Converter<Date>() {
        Date convert(ResultSet rs) throws SQLException {
            return rs.getDate(1);
        }
    };
    private static final Converter<Time> TIME_CONVERTER = new Converter<Time>() {
        Time convert(ResultSet rs) throws SQLException {
            return rs.getTime(1);
        }
    };
    private static final Converter<Timestamp> TIMESTAMP_CONVERTER = new Converter<Timestamp>() {
        Timestamp convert(ResultSet rs) throws SQLException {
            return rs.getTimestamp(1);
        }
    };
    private static final Converter<Object> OBJECT_CONVERTER = new Converter<Object>() {
        Object convert(ResultSet rs) throws SQLException {
            return rs.getObject(1);
        }
    };
    private static final Converter<String> CLOB_CONVERTER = new Converter<String>() {
        String convert(ResultSet rs) throws SQLException {
            return Impl.getCLOB(rs, 1);
        }
    };
    private static final Converter<byte[]> BLOB_CONVERTER = new Converter<byte[]>() {
        byte[] convert(ResultSet rs) throws SQLException {
            return Impl.getBLOB(rs, 1);
        }
    };

    private static boolean checkNext(ResultSet rs, boolean optional) throws SQLException {
        boolean hasNext = rs.next();
        if (!hasNext) {
            if (optional) {
                return false;
            } else {
                throw new SQLException("No rows found");
            }
        } else {
            return true;
        }
    }

    private static void tooManyRows(ResultSet rs) throws SQLException {
        if (rs.next())
            throw new SQLException("Too many rows");
    }

    private <T> T singleOrOptionalRowQueryReturningT(PreparedStatement stmt, boolean optional, boolean checkNull,
                                                     Class<T> cls, boolean special, Converter<T> converter) throws SQLException {
        ResultSet rs = null;
        try {
            rs = stmt.executeQuery();
            if (test != null) {
                test.checkOneColumn(stmt, rs, cls, special);
                return special ? null : cls.cast(test.getTestObject(cls));
            } else {
                if (!checkNext(rs, optional))
                    return null;
                T x = converter.convert(rs);
                T ret;
                if (checkNull && rs.wasNull()) {
                    ret = null;
                } else {
                    ret = x;
                }
                tooManyRows(rs);
                return ret;
            }
        } finally {
            close(rs, stmt);
        }
    }

    private <T> T singleRowQueryReturningT(PreparedStatement stmt, boolean checkNull, Class<T> cls, boolean special, Converter<T> converter) throws SQLException {
        return singleOrOptionalRowQueryReturningT(stmt, false, checkNull, cls, special, converter);
    }

    private <T> T optionalRowQueryReturningT(PreparedStatement stmt, boolean checkNull, Class<T> cls, boolean special, Converter<T> converter) throws SQLException {
        return singleOrOptionalRowQueryReturningT(stmt, true, checkNull, cls, special, converter);
    }

    private <T> List<T> columnOfT(PreparedStatement stmt, Class<T> special, Converter<T> converter) throws SQLException {
        ResultSet rs = null;
        try {
            List<T> list = new ArrayList<>();
            if (test != null) {
                test.checkOneColumn(stmt, rs, special, special != null);
            } else {
                rs = stmt.executeQuery();
                while (rs.next()) {
                    list.add(converter.convert(rs));
                }
            }
            return list;
        } finally {
            close(rs, stmt);
        }
    }

    ///////////////////////////////// Primitive Sinlge row statements /////////////////////////////////

    /**
     * Executes select query, which should return one row and one column (more or less than
     * one row raises runtime exception, more or less than one column raises
     * preprocess-time exception). Result is returned as a single <code>int</code>. NULLs are returned as zeroes.
     * Closes statement after execution.
     */
    public final int singleRowQueryReturningInt(PreparedStatement stmt) throws SQLException {
        return singleRowQueryReturningT(stmt, false, Integer.class, false, INT_CONVERTER).intValue();
    }

    /**
     * Executes select query, which should return one row and one column (more or less than
     * one row raises runtime exception, more or less than one column raises
     * preprocess-time exception). Result is returned as a single <code>long</code>. NULLs are returned as zeroes.
     * Closes statement after execution.
     */
    public final long singleRowQueryReturningLong(PreparedStatement stmt) throws SQLException {
        return singleRowQueryReturningT(stmt, false, Long.class, false, LONG_CONVERTER).longValue();
    }

    /**
     * Executes select query, which should return one row and one column (more or less than
     * one row raises runtime exception, more or less than one column raises
     * preprocess-time exception). Result is returned as a single <code>double</code>. NULLs are returned as zeroes.
     * Closes statement after execution.
     */
    public final double singleRowQueryReturningDouble(PreparedStatement stmt) throws SQLException {
        return singleRowQueryReturningT(stmt, false, Double.class, false, DOUBLE_CONVERTER).doubleValue();
    }

    ///////////////////////////////// Nullable primitive single row statements /////////////////////////////////

    /**
     * Executes select query, which should return one row and one column (more or less than
     * one row raises runtime exception, more or less than one column raises
     * preprocess-time exception). Result is returned as a single {@link Integer}. NULLs are returned as null.
     * Closes statement after execution.
     */
    public final Integer singleRowQueryReturningINT(PreparedStatement stmt) throws SQLException {
        return singleRowQueryReturningT(stmt, true, Integer.class, false, INT_CONVERTER);
    }

    /**
     * Executes select query, which should return one row and one column (more or less than
     * one row raises runtime exception, more or less than one column raises
     * preprocess-time exception). Result is returned as a single {@link Long}. NULLs are returned as null.
     * Closes statement after execution.
     */
    public final Long singleRowQueryReturningLONG(PreparedStatement stmt) throws SQLException {
        return singleRowQueryReturningT(stmt, true, Long.class, false, LONG_CONVERTER);
    }

    /**
     * Executes select query, which should return one row and one column (more or less than
     * one row raises runtime exception, more or less than one column raises
     * preprocess-time exception). Result is returned as a single {@link Double}. NULLs are returned as null.
     * Closes statement after execution.
     */
    public final Double singleRowQueryReturningDOUBLE(PreparedStatement stmt) throws SQLException {
        return singleRowQueryReturningT(stmt, true, Double.class, false, DOUBLE_CONVERTER);
    }

    ///////////////////////////////// Object single row statements /////////////////////////////////

    /**
     * Executes select query, which should return one row and one column (more or less than
     * one row raises runtime exception, more or less than one column raises
     * preprocess-time exception). Result is returned as a single {@link String}.
     * Closes statement after execution.
     */
    public final String singleRowQueryReturningString(PreparedStatement stmt) throws SQLException {
        return singleRowQueryReturningT(stmt, false, String.class, false, STRING_CONVERTER);
    }

    /**
     * Executes select query, which should return one row and one column (more or less than
     * one row raises runtime exception, more or less than one column raises
     * preprocess-time exception). Result is returned as a single <code>byte[]</code>.
     * Closes statement after execution.
     */
    public final byte[] singleRowQueryReturningBytes(PreparedStatement stmt) throws SQLException {
        return singleRowQueryReturningT(stmt, false, byte[].class, false, BYTES_CONVERTER);
    }

    /**
     * Executes select query, which should return one row and one column (more or less than
     * one row raises runtime exception, more or less than one column raises
     * preprocess-time exception). Result is returned as a single {@link BigDecimal}.
     * Closes statement after execution.
     */
    public final BigDecimal singleRowQueryReturningBigDecimal(PreparedStatement stmt) throws SQLException {
        return singleRowQueryReturningT(stmt, false, BigDecimal.class, false, BIGDECIMAL_CONVERTER);
    }

    /**
     * Executes select query, which should return one row and one column (more or less than
     * one row raises runtime exception, more or less than one column raises
     * preprocess-time exception). Result is returned as a single {@link Date}.
     * Closes statement after execution.
     */
    public final Date singleRowQueryReturningDate(PreparedStatement stmt) throws SQLException {
        return singleRowQueryReturningT(stmt, false, Date.class, false, DATE_CONVERTER);
    }

    /**
     * Executes select query, which should return one row and one column (more or less than
     * one row raises runtime exception, more or less than one column raises
     * preprocess-time exception). Result is returned as a single {@link Time}.
     * Closes statement after execution.
     */
    public final Time singleRowQueryReturningTime(PreparedStatement stmt) throws SQLException {
        return singleRowQueryReturningT(stmt, false, Time.class, false, TIME_CONVERTER);
    }

    /**
     * Executes select query, which should return one row and one column (more or less than
     * one row raises runtime exception, more or less than one column raises
     * preprocess-time exception). Result is returned as a single {@link Timestamp}.
     * Closes statement after execution.
     */
    public final Timestamp singleRowQueryReturningTimestamp(PreparedStatement stmt) throws SQLException {
        return singleRowQueryReturningT(stmt, false, Timestamp.class, false, TIMESTAMP_CONVERTER);
    }

    /**
     * Executes select query, which should return one row and one column (more or less than
     * one row raises runtime exception, more or less than one column raises
     * preprocess-time exception). Result is returned as a single {@link Object}.
     * Closes statement after execution.
     */
    public final Object singleRowQueryReturningObject(PreparedStatement stmt) throws SQLException {
        return singleRowQueryReturningT(stmt, false, Object.class, false, OBJECT_CONVERTER);
    }

    /**
     * Executes select query, which should return one row and one column (more or less than
     * one row raises runtime exception, more or less than one column raises
     * preprocess-time exception). Result is returned as a single {@link String}.
     * Closes statement after execution.
     */
    public final String singleRowQueryReturningClob(PreparedStatement stmt) throws SQLException {
        return singleRowQueryReturningT(stmt, false, String.class, false, CLOB_CONVERTER);
    }

    /**
     * Executes select query, which should return one row and one column (more or less than
     * one row raises runtime exception, more or less than one column raises
     * preprocess-time exception). Result is returned as a single <code>byte[]</code>.
     * Closes statement after execution.
     */
    public final byte[] singleRowQueryReturningBlob(PreparedStatement stmt) throws SQLException {
        return singleRowQueryReturningT(stmt, false, byte[].class, false, BLOB_CONVERTER);
    }

    /**
     * Executes select query, which should return one row and one column (more or less than
     * one row raises runtime exception, more or less than one column raises
     * preprocess-time exception).
     * Closes statement after execution.
     *
     * @param cls class with user-defined mapping (see {@link Mapper} and {@link RuntimeMapper})
     */
    public final <T> T singleRowQueryReturning(Class<T> cls, PreparedStatement stmt) throws SQLException {
        CustomMapper<T> mapper = getMapper(cls);
        return singleRowQueryReturningT(stmt, false, cls, true, new Converter<T>() {
            T convert(ResultSet rs) throws SQLException {
                return mapper.fetch(rs, 1, 1, cls);
            }
        });
    }

    ///////////////////////////////// Optional row statements /////////////////////////////////

    /**
     * Same as {@link #singleRowQueryReturningInt(PreparedStatement)} but returns
     * null when no rows found.
     */
    public final Integer optionalRowQueryReturningInt(PreparedStatement stmt) throws SQLException {
        return optionalRowQueryReturningT(stmt, true, Integer.class, false, INT_CONVERTER);
    }

    /**
     * Same as {@link #singleRowQueryReturningLong(PreparedStatement)} but returns
     * null when no rows found.
     */
    public final Long optionalRowQueryReturningLong(PreparedStatement stmt) throws SQLException {
        return optionalRowQueryReturningT(stmt, true, Long.class, false, LONG_CONVERTER);
    }

    /**
     * Same as {@link #singleRowQueryReturningDouble(PreparedStatement)} but returns
     * null when no rows found.
     */
    public final Double optionalRowQueryReturningDouble(PreparedStatement stmt) throws SQLException {
        return optionalRowQueryReturningT(stmt, true, Double.class, false, DOUBLE_CONVERTER);
    }

    /**
     * Same as {@link #singleRowQueryReturningString(PreparedStatement)} but returns
     * null when no rows found.
     */
    public final String optionalRowQueryReturningString(PreparedStatement stmt) throws SQLException {
        return optionalRowQueryReturningT(stmt, false, String.class, false, STRING_CONVERTER);
    }

    /**
     * Same as {@link #singleRowQueryReturningBytes(PreparedStatement)} but returns
     * null when no rows found.
     */
    public final byte[] optionalRowQueryReturningBytes(PreparedStatement stmt) throws SQLException {
        return optionalRowQueryReturningT(stmt, false, byte[].class, false, BYTES_CONVERTER);
    }

    /**
     * Same as {@link #singleRowQueryReturningBigDecimal(PreparedStatement)} but returns
     * null when no rows found.
     */
    public final BigDecimal optionalRowQueryReturningBigDecimal(PreparedStatement stmt) throws SQLException {
        return optionalRowQueryReturningT(stmt, false, BigDecimal.class, false, BIGDECIMAL_CONVERTER);
    }

    /**
     * Same as {@link #singleRowQueryReturningDate(PreparedStatement)} but returns
     * null when no rows found.
     */
    public final Date optionalRowQueryReturningDate(PreparedStatement stmt) throws SQLException {
        return optionalRowQueryReturningT(stmt, false, Date.class, false, DATE_CONVERTER);
    }

    /**
     * Same as {@link #singleRowQueryReturningTime(PreparedStatement)} but returns
     * null when no rows found.
     */
    public final Time optionalRowQueryReturningTime(PreparedStatement stmt) throws SQLException {
        return optionalRowQueryReturningT(stmt, false, Time.class, false, TIME_CONVERTER);
    }

    /**
     * Same as {@link #singleRowQueryReturningTimestamp(PreparedStatement)} but returns
     * null when no rows found.
     */
    public final Timestamp optionalRowQueryReturningTimestamp(PreparedStatement stmt) throws SQLException {
        return optionalRowQueryReturningT(stmt, false, Timestamp.class, false, TIMESTAMP_CONVERTER);
    }

    /**
     * Same as {@link #singleRowQueryReturningClob(PreparedStatement)} but returns
     * null when no rows found.
     */
    public final String optionalRowQueryReturningClob(PreparedStatement stmt) throws SQLException {
        return optionalRowQueryReturningT(stmt, false, String.class, false, CLOB_CONVERTER);
    }

    /**
     * Same as {@link #singleRowQueryReturningBlob(PreparedStatement)} but returns
     * null when no rows found.
     */
    public final byte[] optionalRowQueryReturningBlob(PreparedStatement stmt) throws SQLException {
        return optionalRowQueryReturningT(stmt, false, byte[].class, false, BLOB_CONVERTER);
    }

    /**
     * Same as {@link #singleRowQueryReturningObject(PreparedStatement)} but returns
     * null when no rows found.
     */
    public final Object optionalRowQueryReturningObject(PreparedStatement stmt) throws SQLException {
        return optionalRowQueryReturningT(stmt, false, Object.class, false, OBJECT_CONVERTER);
    }

    /**
     * Same as {@link #singleRowQueryReturning(Class, PreparedStatement)} but returns
     * null when no rows found.
     *
     * @param cls class with user-defined mapping (see {@link Mapper} and {@link RuntimeMapper})
     */
    public final <T> T optionalRowQueryReturning(Class<T> cls, PreparedStatement stmt) throws SQLException {
        CustomMapper<T> mapper = getMapper(cls);
        return optionalRowQueryReturningT(stmt, false, cls, true, new Converter<T>() {
            T convert(ResultSet rs) throws SQLException {
                return mapper.fetch(rs, 1, 1, cls);
            }
        });
    }

    ///////////////////////////////// Column statements /////////////////////////////////

    /**
     * Executes select query returning single column of <code>int</code>.
     * Closes statement after execution.
     */
    public final int[] columnOfInt(PreparedStatement stmt) throws SQLException {
        List<Integer> list = columnOfT(stmt, null, INT_CONVERTER);
        int[] ret = new int[list.size()];
        for (int i = 0; i < list.size(); i++) {
            ret[i] = list.get(i).intValue();
        }
        return ret;
    }

    /**
     * Executes select query returning single column of <code>long</code>.
     * Closes statement after execution.
     */
    public final long[] columnOfLong(PreparedStatement stmt) throws SQLException {
        List<Long> list = columnOfT(stmt, null, LONG_CONVERTER);
        long[] ret = new long[list.size()];
        for (int i = 0; i < list.size(); i++) {
            ret[i] = list.get(i).longValue();
        }
        return ret;
    }

    /**
     * Executes select query returning single column of <code>double</code>.
     * Closes statement after execution.
     */
    public final double[] columnOfDouble(PreparedStatement stmt) throws SQLException {
        List<Double> list = columnOfT(stmt, null, DOUBLE_CONVERTER);
        double[] ret = new double[list.size()];
        for (int i = 0; i < list.size(); i++) {
            ret[i] = list.get(i).doubleValue();
        }
        return ret;
    }

    /**
     * Executes select query returning single column of {@link String}.
     * Closes statement after execution.
     */
    public final String[] columnOfString(PreparedStatement stmt) throws SQLException {
        List<String> list = columnOfT(stmt, null, STRING_CONVERTER);
        return list.toArray(new String[0]);
    }

    /**
     * Executes select query returning single column of {@link Object}.
     * Closes statement after execution.
     */
    public final Object[] columnOfObject(PreparedStatement stmt) throws SQLException {
        List<Object> list = columnOfT(stmt, null, OBJECT_CONVERTER);
        return list.toArray(new Object[0]);
    }

    /**
     * Executes select query returning single column of T.
     * Closes statement after execution.
     *
     * @param cls class with user-defined mapping (see {@link Mapper} and {@link RuntimeMapper})
     */
    public final <T> List<T> columnOf(Class<T> cls, PreparedStatement stmt) throws SQLException {
        CustomMapper<T> mapper = getMapper(cls);
        return columnOfT(stmt, cls, new Converter<T>() {
            T convert(ResultSet rs) throws SQLException {
                return mapper.fetch(rs, 1, 1, cls);
            }
        });
    }

    ///////////////////////////////// Class statements /////////////////////////////////

    private <T> T fetchFromResultSet(Class<T> cls, ResultSet rs) throws SQLException {
        Object[] params = {rs, this};
        RowTypeFactory factory = lwb.findFactory(cls, getClass());
        return cls.cast(factory.call(params));
    }

    private <T> T singleOrOptionalRowQuery(PreparedStatement stmt, boolean optional, Class<T> cls) throws SQLException {
        ResultSet rs = null;
        try {
            if (test != null) {
                test.getFields(cls, stmt, rs, false);
                return null;
            } else {
                rs = stmt.executeQuery();
                if (!checkNext(rs, optional))
                    return null;
                T ret = fetchFromResultSet(cls, rs);
                tooManyRows(rs);
                return ret;
            }
        } finally {
            close(rs, stmt);
        }
    }

    /**
     * Executes select query, which should return exactly one row (more or less than
     * one rows raises runtime exception).
     * Result is returned as an object which class implementation is generated by preprocessor.
     * Closes statement after execution.
     *
     * @param stmt SQL statement
     * @param cls row type class or interface generated by preprocessor (see {@link RowType}).
     */
    public final <T> T singleRowQuery(PreparedStatement stmt, Class<T> cls) throws SQLException {
        return singleOrOptionalRowQuery(stmt, false, cls);
    }

    /**
     * Same as {@link #singleRowQuery(PreparedStatement, Class)} but returns
     * null when no rows found.
     */
    public final <T> T optionalRowQuery(PreparedStatement stmt, Class<T> cls) throws SQLException {
        return singleOrOptionalRowQuery(stmt, true, cls);
    }

    /**
     * Executes select query returning multiple (zero or more) rows.
     * Result is returned as a list of objects which class implementation is generated by preprocessor.
     * Closes statement after execution.
     *
     * @param stmt SQL statement
     * @param cls row type class or interface generated by preprocessor (see {@link RowType}).
     */
    public final <T> List<T> multiRowQuery(PreparedStatement stmt, Class<T> cls) throws SQLException {
        ResultSet rs = null;
        try {
            List<T> result = new ArrayList<>();
            if (test != null) {
                test.getFields(cls, stmt, rs, false);
            } else {
                rs = stmt.executeQuery();
                getResultSet(cls, rs, result);
            }
            return result;
        } finally {
            close(rs, stmt);
        }
    }

    private <T> void getResultSet(Class<T> cls, ResultSet rs, List<T> result) throws SQLException {
        Object[] params = {rs, this};
        RowTypeFactory factory = lwb.findFactory(cls, getClass());
        while (rs.next()) {
            T row = cls.cast(factory.call(params));
            result.add(row);
        }
    }

    private <T> void getResultSet(ResultSet rs, TypedList<T> list) throws SQLException {
        getResultSet(list.cls, rs, list.list);
    }

    /**
     * Returns query ResultSet metadata as RowType object.
     */
    public final <T> T metaRowQuery(PreparedStatement stmt, Class<T> cls) throws SQLException {
        ResultSet rs = null;
        try {
            if (test != null) {
                test.getFields(cls, stmt, rs, true);
                return null;
            } else {
                rs = stmt.executeQuery();
                return fetchFromResultSet(cls, rs);
            }
        } finally {
            close(rs, stmt);
        }
    }

    ///////////////////////////////// Executing DML /////////////////////////////////

    /**
     * Executes update/delete/insert SQL statement. This method should always be used
     * instead of {@link PreparedStatement#executeUpdate()} because the latter can modify
     * database state at preprocess phase.
     * <p>
     * This method does not close statement, so it can be called multiple times.
     * You don't have to close statement manually if it was created with {@link #prepareStatement(String, Parameter...)} or the like,
     * because all statements created with {@link GBase} methods are closed automatically after business method exit.
     *
     * @param stmt SQL statement
     * @return number of modified database rows
     */
    public final int executeUpdate(PreparedStatement stmt) throws SQLException {
        return executeUpdate(stmt, true);
    }

    /**
     * Same as {@link #executeUpdate(PreparedStatement)} but closes statement when <code>reuse=false</code>.
     *
     * @param stmt SQL statement
     * @param reuse false if close statement after execution
     * @return number of modified database rows
     */
    public final int executeUpdate(PreparedStatement stmt, boolean reuse) throws SQLException {
        try {
            if (test != null) {
                test.checkSql(stmt);
                return 0;
            } else {
                return stmt.executeUpdate();
            }
        } finally {
            if (!reuse) {
                close(null, stmt);
            }
        }
    }

    /**
     * Returns array of auto-generated keys for insert/update statement. List of auto-generated
     * columns is provided by {@link #prepareStatementKey} <code>autoKeys</code>
     * parameter or by {@link PrepareKey} annotation value. Number of elements in array is equal to the number
     * of auto-generated columns.
     */
    public final Number[] getGeneratedKeys(PreparedStatement stmt) throws SQLException {
        if (test != null) {
            Number[] ret = new Number[10];
            Arrays.fill(ret, 0);
            return ret;
        } else {
            ResultSet rs = null;
            try {
                rs = stmt.getGeneratedKeys();
                ResultSetMetaData rsmd = rs.getMetaData();
                int count = rsmd.getColumnCount();
                rs.next();
                Number[] ret = new Number[count];
                for (int i = 0; i < count; i++) {
                    ret[i] = (Number) rs.getObject(i + 1);
                }
                return ret;
            } finally {
                close(rs, stmt);
            }
        }
    }

    ///////////////////////////////// Executing calls /////////////////////////////////

    /**
     * Executes PL/SQL block constructed from pieces.
     *
     * @param query query text and parameter values
     * @return array of all OUT parameter values
     */
    public final Object[] executeCall(QueryPiece query) throws SQLException {
        return executeCall(query.sql, query.data);
    }

    private Object[] getOutParameters(CallableStatement cs, Parameter[] in) throws SQLException {
        List<Object> result = new ArrayList<>();
        boolean executed = false;
        for (int i = 0; i < in.length; i++) {
            int j = i + 1;
            Parameter out = in[i];
            if (!out.isOut())
                continue;
            TypedList<?> typedList = out.getResultSet();
            Object res;
            if (typedList != null) {
                Class<?> type = typedList.cls;
                if (test != null) {
                    if (!executed) {
                        cs.execute();
                        executed = true;
                    }
                    ResultSet rs = (ResultSet) cs.getObject(j);
                    test.getFields(type, null, rs, typedList.meta);
                } else {
                    try (ResultSet rs = (ResultSet) cs.getObject(j)) {
                        getResultSet(rs, typedList);
                    }
                }
                res = typedList.list;
            } else {
                res = out.get(this, cs, j);
            }
            result.add(res);
        }
        return result.toArray(new Object[0]);
    }

    /**
     * Executes callable statement.
     * Example:
     * <pre>
     * Object[] ret = executeCall("{ call trace(?) }", in(message, String.class));
     * </pre>
     * It is more convenient to use {@link Call} annotation to generate such calls than
     * to use this method manually.
     *
     * @param sql SQL to execute as CallableStatement.
     * Syntax is the same as for {@link Connection#prepareCall(String)}:
     * <ul>
     * <li>{ call proc_name(params) } or { ? = func_name(params) }
     * <li>begin ... end;
     * </ul>
     * @param params input/output parameters array (see {@link #in} and {@link #out}).
     * @return output parameters' values, always not null. Length of the array equals to the number of OUT parameters.
     */
    public final Object[] executeCall(String sql, Parameter... params) throws SQLException {
        CallableStatement cs = prepareCall(sql);
        setSql(sql, params);
        try {
            Parameter.setParameters(this, cs, params);
            if (test != null) {
                test.checkSql(cs);
            } else {
                cs.execute();
            }
            return getOutParameters(cs, params);
        } finally {
            close(cs);
        }
    }

    private static String getProcCallSql(String name, Parameter[] in) {
        StringBuilder buf = new StringBuilder("{ call " + name + "(");
        int argCount = in.length;
        for (int i = 0; i < argCount; i++) {
            if (i > 0)
                buf.append(", ");
            buf.append("?");
        }
        buf.append(") }");
        return buf.toString();
    }

    /**
     * Calls stored procedure.
     * Example:
     * <pre>
     * Object[] ret = callStoredProc("trace", in(message, String.class));
     * </pre>
     *
     * @param name Stored procedure name. SQL statement is generated by procedure name
     * and parameters as <code>{ call name(in) }</code>.
     * @param in input/output parameters array (see {@link #in} and {@link #out}).
     * @return output parameters' values, always not null. Length of the array equals to the number of OUT parameters.
     */
    public final Object[] callStoredProc(String name, Parameter... in) throws SQLException {
        if (test != null) {
            test.checkStoredProcName(name, in);
        }
        String sql = getProcCallSql(name, in);
        return executeCall(sql, in);
    }

    /**
     * Executes PL/SQL block. Other parameters see {@link #callStoredProc}.
     *
     * @param block PL/SQL block text (BEGIN ... END;)
     * @param in input/output parameters array (see {@link #in} and {@link #out}).
     * @return output parameters' values, always not null. Length of the array equals to the number of OUT parameters.
     */
    public final Object[] callStoredBlock(String block, Parameter... in) throws SQLException {
        return executeCall(block, in);
    }

    /**
     * Executes stored procedure or PL/SQL block.
     * Does not close statement, you can explicitly call {@link #endCall(CallableStatement)} to close it.
     * You can retrieve OUT parameters with <code>getXXX(CallableStatement, int)</code> methods after call to this method.
     */
    public final void executeCall(CallableStatement stmt) throws SQLException {
        if (test != null) {
            test.checkSql(stmt);
        } else {
            stmt.execute();
        }
    }

    /**
     * Closes CallableStatement.
     */
    public final void endCall(CallableStatement stmt) {
        close(null, stmt);
    }

    ///////////////////////////////// Callable statement OUT parameters /////////////////////////////////

    /**
     * Returns OUT parameter of stored procedure with index i (from 1) as {@link Integer}.
     */
    public static Integer getInt(CallableStatement stmt, int i) throws SQLException {
        if (test != null)
            return GTest.INT;
        int x = stmt.getInt(i);
        if (stmt.wasNull())
            return null;
        return x;
    }

    /**
     * Returns OUT parameter of stored procedure with index i (from 1) as {@link Long}.
     */
    public static Long getLong(CallableStatement stmt, int i) throws SQLException {
        if (test != null)
            return GTest.LONG;
        long x = stmt.getLong(i);
        if (stmt.wasNull())
            return null;
        return x;
    }

    /**
     * Returns OUT parameter of stored procedure with index i (from 1) as {@link Double}.
     */
    public static Double getDouble(CallableStatement stmt, int i) throws SQLException {
        if (test != null)
            return GTest.DOUBLE;
        double x = stmt.getDouble(i);
        if (stmt.wasNull())
            return null;
        return x;
    }

    /**
     * Returns OUT parameter of stored procedure with index i (from 1) as {@link String}.
     */
    public static String getString(CallableStatement stmt, int i) throws SQLException {
        if (test != null)
            return GTest.STRING;
        return stmt.getString(i);
    }

    /**
     * Returns OUT parameter of stored procedure with index i (from 1) as <code>byte[]</code>.
     */
    public static byte[] getBytes(CallableStatement stmt, int i) throws SQLException {
        if (test != null)
            return GTest.bytesValue();
        return stmt.getBytes(i);
    }

    /**
     * Returns OUT parameter of stored procedure with index i (from 1) as {@link BigDecimal}.
     */
    public static BigDecimal getBigDecimal(CallableStatement stmt, int i) throws SQLException {
        if (test != null)
            return GTest.BIG_DECIMAL;
        return stmt.getBigDecimal(i);
    }

    /**
     * Returns OUT parameter of stored procedure with index i (from 1) as {@link Date}.
     */
    public static Date getDate(CallableStatement stmt, int i) throws SQLException {
        if (test != null)
            return GTest.dateValue();
        return stmt.getDate(i);
    }

    /**
     * Returns OUT parameter of stored procedure with index i (from 1) as {@link Time}.
     */
    public static Time getTime(CallableStatement stmt, int i) throws SQLException {
        if (test != null)
            return GTest.timeValue();
        return stmt.getTime(i);
    }

    /**
     * Returns OUT parameter of stored procedure with index i (from 1) as {@link Timestamp}.
     */
    public static Timestamp getTimestamp(CallableStatement stmt, int i) throws SQLException {
        if (test != null)
            return GTest.timestampValue();
        return stmt.getTimestamp(i);
    }

    /**
     * Returns OUT parameter of stored procedure with index i (from 1) as {@link Object}.
     */
    public static Object getObject(CallableStatement stmt, int i) throws SQLException {
        if (test != null)
            return GTest.objectValue();
        return stmt.getObject(i);
    }

    ///////////////////////////////// Executing raw SQL /////////////////////////////////

    /**
     * Executes SQL statement. It is executed only at runtime, at preprocess time SQL is only checked for validity.
     *
     * @param sql SQL statement to execute
     */
    public final void executeSql(String sql) throws SQLException {
        setSql(sql, null);
        if (test != null) {
            test.checkSql(sql);
            return;
        }
        try (Statement st = getConnection().createStatement()) {
            st.execute(sql);
        }
        // ignore
    }

    /**
     * Creates Statement.
     * <p>
     * <b>Warning:</b> usually you should call this method <b>only</b> at application run time, not at
     * preprocess time, because it can alter DB state (for example, when you execute <code>DROP TABLE</code>
     * statement). Since preprocessor executes business method code and it is undesirable for preprocessor
     * to alter DB state, calls to this method should be guarded by check of {@link #isTesting()}:
     * <pre>
     * if (isTesting()) {
     *     Statement st = createStatement();
     *     st.execute("DROP TABLE BOBBY");
     * }
     * </pre>
     */
    public final Statement createStatement() throws SQLException {
        Statement st = getConnection().createStatement();
        statementCreated(st, null);
        return st;
    }

    ///////////////////////////////// Closing statements /////////////////////////////////

    /**
     * Closes statement.
     */
    public final void close(Statement st) {
        ResultSet rs = null;
        try {
            rs = st.getResultSet();
        } catch (SQLException ex) {
            // ignore
        }
        close(rs, st, true);
    }

    /**
     * Closes result set and statement.
     */
    public final void close(ResultSet rs, Statement st) {
        close(rs, st, true);
    }

    private void close(ResultSet rs, Statement st, boolean remove) {
        if (rs != null) {
            try {
                rs.close();
            } catch (SQLException ex) {
                // ignore
            }
        }
        if (st != null) {
            try {
                st.close();
            } catch (SQLException ex) {
                // ignore
            }
            if (remove) {
                if (statements != null) {
                    statements.remove(st);
                }
            }
        }
    }

    /**
     * Closes all open statements (usually this method is called by wrappers automatically).
     */
    public final void closeStatements() {
        if (statements != null) {
            for (Statement stmt : statements) {
                ResultSet rs = null;
                try {
                    rs = stmt.getResultSet();
                } catch (SQLException ex) {
                    // ignore
                }
                close(rs, stmt, false);
            }
            statements.clear();
        }
    }

    ///////////////////////////////// Utility methods /////////////////////////////////

    /**
     * Create row instance by row type class; class should have {@link EditableRowType} annotation.
     * Returns <code>null</code>) at preprocess time (because implementation class isn't generated yet).
     */
    public final <T> T newRow(Class<T> cls) {
        if (test != null)
            return null;
        Constructor<?> cons = LocalWrapperBase.getDefaultConstructor(cls);
        try {
            return cls.cast(cons.newInstance());
        } catch (Exception ex) {
            throw new SQLGException(ex.getMessage(), ex);
        }
    }

    /**
     * Writes text to CLOB. Statement should contain <code>SELECT ... FOR UPDATE</code>
     * SQL statement.
     * This method does NOT write <code>EMPTY_CLOB</code> before writing data, so you should
     * do it yourself if required.
     * Closes statement after execution.
     *
     * @param stmt <code>SELECT ... FOR UPDATE</code> SQL statement
     * @param text text to write
     */
    public final void setClob(PreparedStatement stmt, String text) throws SQLException {
        if (test != null) {
            test.checkSql(stmt);
            return;
        }
        if (text == null) {
            close(null, stmt);
            return;
        }
        ResultSet rs = null;
        Writer wr = null;
        try {
            rs = stmt.executeQuery();
            if (rs.next()) {
                Clob clob = rs.getClob(1);
                wr = lwb.getSpecific().getClobWriter(clob);
                wr.write(text);
                wr.close();
            }
        } catch (IOException ex) {
            throw Impl.wrap(ex);
        } finally {
            if (wr != null) {
                try {
                    wr.close();
                } catch (IOException ex) {
                    // ignore
                }
            }
            close(rs, stmt);
        }
    }

    /**
     * Writes bytes to BLOB. Statement should contain <code>SELECT ... FOR UPDATE</code>
     * SQL statement.
     * This method does NOT write <code>EMPTY_BLOB</code> before writing data, so you should
     * do it yourself if required.
     * Closes statement after execution.
     *
     * @param stmt <code>SELECT ... FOR UPDATE</code> SQL statement
     * @param data bytes to write
     */
    public final void setBlob(PreparedStatement stmt, byte[] data) throws SQLException {
        if (test != null) {
            test.checkSql(stmt);
            return;
        }
        if (data == null) {
            close(null, stmt);
            return;
        }
        ResultSet rs = null;
        OutputStream wr = null;
        try {
            rs = stmt.executeQuery();
            if (rs.next()) {
                Blob blob = rs.getBlob(1);
                wr = lwb.getSpecific().getBlobOutputStream(blob);
                wr.write(data);
                wr.close();
            }
        } catch (IOException ex) {
            throw Impl.wrap(ex);
        } finally {
            if (wr != null) {
                try {
                    wr.close();
                } catch (IOException ex) {
                    // ignore
                }
            }
            close(rs, stmt);
        }
    }

    /**
     * Returns next number in sequence.
     *
     * @param sequence sequence name
     */
    public final long getNextId(String sequence) throws SQLException {
        if (test != null) {
            test.checkSequenceExists(sequence);
            return 0;
        }
        setSql(sequence + ".NEXTVAL", null);
        return lwb.getSpecific().getNextId(getConnection(), sequence);
    }

    /**
     * Returns data access interface generated by preprocessor.
     *
     * @param iface interface class
     * @return data access interface implementation object working
     * in current transaction
     */
    public final <T extends IDBCommon> T getInterface(Class<T> iface) {
        if (test != null) {
            return test.getNullInterface(iface);
        } else {
            return lwb.getInlineInterface(iface);
        }
    }

    /**
     * Returns Java/SQL mapping for custom class.
     *
     * @param cls custom-mapped class
     */
    final <T> CustomMapper<T> getMapper(Class<T> cls) {
        return lwb.getMapper(getClass()).getMapper(cls);
    }

    /**
     * Fetches custom-mapped class from result set. See {@link CustomMapper#fetch}.
     * Usually called by generated wrappers.
     *
     * @param cls custom-mapped class
     * @param rs result set
     * @param from first column of result set
     * @param to last column of result set
     * @return instance of custom-mapped class fetched from result set
     */
    public final <T> T fetch(Class<T> cls, ResultSet rs, int from, int to) throws SQLException {
        return getMapper(cls).fetch(rs, from, to, cls);
    }

    public final SQLGLogger getLogger() {
        return lwb.getLogger();
    }
}
